# item10

## equals는 일반 규약을 지켜 재정의하라

### equals를 재정의 하지 않는 상황 
```
1. 각 인스턴스가 본질적으로 고유할 때. (Thread, etc.)
2. 인스턴스의 '논리적 동치성'을 검사할 일이 없을 때. 
3. 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞을 때 (Set, List, Map, etc.)
4. 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없을 때. 
```

### equals를 재정의 할 때 - When? 
```
객체 식별성이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때. (Integer, String, etc.)
```

### equals 재정의 일반 규약 
```
1. 반사성: null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true다. 
2. 대칭성: null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.  
3. 추이성: null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true이고 y.equals(z)도 true면 x.equals(z)도 true다.
4. 일관성: null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다. 
5. null-아님: null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다. 
```

### 1. 반사성 
```
객체는 자기 자신과 같아야 한다. 
```

### 2. 대칭성 
```
두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다. 
```

### 3. 추이성 
```
첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다는 뜻이다. 
```

### 4. 일관성 
```
두 객체가 같다면 앞으로도 영원히 같아야 한다는 뜻이다. 
```

### 5. null-아님
```
모든 객체가 null과 같지 않아야 한다는 뜻이다. 
```

### 양질의 equals 메서드 구현 방법 
```
1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인. 
2. instanceof 연산자롤 입력이 올바른 타입인지 확인한다. 
3. 입력을 올바른 타입으로 형변환한다.
4. 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사한다. 
```


# item11

## equals를 재정의하려거든 hashCode도 재정의하라

### hashCode 재정의 
```
equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다. 
hashCode 재정의를 잘못했을 때 문제는 두 객체의 hasCode가 똑같은 값을 반환하지 않는 다는 것이다. Object의 기본 hashCode 메서드는 둘이 전혀 다르다고 판단하여 서로 다른 값을 반환한다. 
```

### 좋은 해시 함수란?
```
좋은 해시 함수라면 서로 다른 인스턴스에 다른 해시코드를 반환한다. 이상적인 해시 함수는 주어진 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다. 
```

# item12

## toString을 항상 재정의하라

### toString 일반 규약 
```
toString의 일반 규약에 따르면 '간결하면서 사람이 읽기 쉬운 형태의 유익한 정보'를 반환해야 한다. 
toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다. 
실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는 게 좋다. 
```

# item13

## clone 재정의는 주의해서 진행하라

### Clone 메서드의 일반 규약 
```
이 객체의 복사본을 생성해 반환한다. '복사'의 정확한 뜻은 그 객체를 구현한 클래스에 따라 다를 수 있다. 
x.clone() != x 
x.clone().getClass() == x.getClass()
관례상 이 메서드가 반환하는 객체는 super.clone을 호출해 얻어야 한다. 
```

### Stack 클래스 복제 
```
Clone메서드가 super.clone의 결과를 그대로 반환한다면 반환된 Stack 인스턴스의 size 필드는 올바른 값을 갖겠지만, elements 필드는 원본 Stack 인스턴스와 똑같은 배열을 참조할 것이다. Stack클래스의 하나뿐인 생성자를 호출한다면 이러한 상황은 절대 일어나지 않는다. clone 메서드는 생성자와 같은 효과를 낸다. 즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다. 
따라서, Stack의 Clone 메서드는 스택 내부 정보를 복사해야 한다 -> elements 배열의 clone을 재귀적으로 호출. 
```

# item14

## Comparable을 구현할지 고려하라

### compareTo 메서드의 일반 규약 
```
1. 두 객체 참조의 순서를 바꿔 비교해도 예상한 결과가 나와야 한다. 
2. 첫번째가 두 번째보다 크고 두 분째가 세 번째보다 크면, 첫 번째는 세 번째보닫 커야 한다. 
3. 크기가 같은 객체들끼리는 어떤 객체와 비교하더라도 항상 같아야 한다. 
``` 






