## [Notion](https://basalt-bathroom-cb4.notion.site/12-16116748c28280419faae9980154a98b?pvs=4)

[ITEM 85: 자바 직렬화의 대안을 찾으라](https://www.notion.so/12-16116748c28280419faae9980154a98b?pvs=21)

[ITEM 86: **Serializable을 구현할지는 신중히 결정하라**](https://www.notion.so/12-16116748c28280419faae9980154a98b?pvs=21)

[ITEM 87: **커스텀 직렬화 형태를 고려해보라**](https://www.notion.so/12-16116748c28280419faae9980154a98b?pvs=21)

[ITEM 88: **readObject 메서드는 방어적으로 작성하라**](https://www.notion.so/12-16116748c28280419faae9980154a98b?pvs=21)

[ITEM 89: **인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라**](https://www.notion.so/12-16116748c28280419faae9980154a98b?pvs=21)

[ITEM 90: 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라](https://www.notion.so/12-16116748c28280419faae9980154a98b?pvs=21)

# 직렬화

직렬화란 자바가 객체를 바이트 스트림으로 인코딩하고 그 바이트 스트림으로부터 다시 객체를 재구성하는 매커니즘이다. 

이번 장은 직렬화가 품고 있는 위험과 그 위험을 최소화하는 방법에 집중한다.

---

## 💡자바 직렬화의 대안을 찾으라

직렬화의 근본적인 문제는 공격 범위가 너무 넓다. 게다가  지속적으로 더 넓어져서 방어하기 어려운 것이다.

ex) OutputInputStream의 `readObject` 메서드를 호출하면서 객체 그래프가 역직렬화(deserialization)됨

### 역직렬화 폭탄

역직렬화에 시간이 오래 걸리는 짧은 스트림을 역직렬화 폭탄이라고 한다.

직렬화 위험을 피하는 방법은 아무것도 역직렬화하지 않는 것이다.

오래된 레거시 시스템으로 직렬화를 대체할 수 없다면 반드시 신뢰할 수 있는 데이터만 역직렬화 하는 것이 좋다.

직렬화를 피할 수 없고 역직렬화한 데이터가 안전하지 확실할 수 없다면 **객체 역직렬화 필터링**을 사용하면 된다.

---

## 💡**Serializable을 구현할지는 신중히 결정하라**

**Serializable 구현은 릴리스 이후 수정이 어려워지므로 신중히 결정해야 한다.**

- 직렬화된 바이트 스트림 인코딩도 하나의 공개 API가 되기 때문이다.
- 클래스의 `private`과 `package-private` 인스턴스 필드마저 API로 공개되기 때문에 캡슐화도 깨진다.

버그와 보안에 취약하다.

- 자바에서는 객체를 생성자를 이용해 만든다. 하지만 직렬화는 기본 방식을 우회하여 객체를 생성하여 ‘숨은 생성자’이다. → 불변식이 깨질 수도 있다.

새 버전 릴리즈 시 테스트 요소가 많아진다.

- 직렬화 가능 클래스가 수정되면, 새 버전의 인스턴스를 직렬화한 후 구버전으로 역직렬화가 가능한지 테스트 해야한다.

상속용 클래스는 `Serializable` 구현을 피하고, 인터페이스도 `Serializable`을 확장하지 않는 것이 좋다.

내부 클래스는 `Serializable`를 구현하면 안된다. (정적 멤버 클래스는 가능)

---

## 💡**커스텀 직렬화 형태를 고려해보라**

기본 직렬화 형태가 적절하지 않다면 커스텀 직렬화 형태를 고려해야 한다.

- 기본 직렬화 형태를 사용한다면 현재의 구현에 종속적이게 되어 유연성, 성능, 정확성과 같은 측면을 고려해야 한다.

이상적인 직렬화

- 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태를 사용해도 된다.

객체의 물리적 표현과 논리적 내용의 차이가 클 때 생기는 문제

- 공개 API가 현재 내부 구현 방식에 영원히 묶임
- 너무 많은 공간 차지
    - 기본 직렬화를 사용할 때 각 노드의 연결 정보까지 모두 포함
- 많은 시간이 걸림
    - 객체 그래프의 위상에 관한 정보를 알 수 없으니, 직접 순회할 수밖에 없다.
- 스택 오버플로우를 발생 시킴
    - 객체 그래프를 재귀 순회한다. 호출 정도가 많아지면 이를 위한 스택도 감당하기 어려움

transient 키워드를 사용하여 특정 필드를 직렬화에서 제외

해당 객체의 논리적 상태와 무관한 필드라고 확신할 때만 `transient`를 통해 기본 직렬화에 생략할 수 있다.

어떤 직렬화 형태를 선택하더라도 직렬화 가능 클래스 모두 SerialVersionUID를 명시적으로 선언하자.

---

## 💡**readObject 메서드는 방어적으로 작성하라**

`readObject` 메서드는 생성자와 같은 수준으로 방어적으로 작성해야 한다.

- `readObject` 메서드는 매개변수로 바이트 스트림을 받는 생성자라고 할 수 있다.
- 보통 바이트 스트림은 정상적으로 생성된 인스턴스를 직렬화해서 만들어진다. 하지만 불변을 깨뜨릴 의도로 만들어진 바이트 스트림을 받으면 문제가 생긴다.

**역직렬화를 할 때는 클라이언트가 접근해서는 안 되는 객체 참조를 갖는 필드는 모두 방어적으로 복사를 해야 한다.**

- 역직렬화 과정에서 방어적 복사와 유효성 검사를 수행해야 한다.
- 방어적 복사를 유효성 검사보다 먼저 수행하자. (final 필드는 불가능)

---

## 💡**인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라**

 `public static final` 필드를 사용하지만, `Serializable`을 구현하게 되는 순간 싱글턴이 아니게 된다. 

### readResolve

`readObject` 메서드가 만든 인스턴스를 다른 것으로 대체할 수 있다. 

이때 `readObject` 가 만들어낸 인스턴스는 가비지 컬렉션의 대상이 됨

싱글턴이나 인스턴스 통제가 필요한 클래스의 경우, 열거 타입을 사용하는 것이 가장 좋은 방법이다.

- 자바가 선언한 상수 외에 다른 객체가 없음을 보장해주기 때문이다.
- `AccessibleObject.setAccessible` 메서드와 같은 리플렉션을 사용했을 때는 예외다.

`readResolve` 메서드를 사용할 경우 주의해야 할 점들이 많으므로, 가능하면 열거 타입을 선호해야 한다.

---

## 💡**직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라**

직렬화된 인스턴스 대신 직렬화 프록시를 사용하면 많은 버그와 보안 문제를 예방할 수 있다.

### 직렬화 프록시

바깥 클래스의 논리적 상태를 표현하는 중첩 클래스를 설계하여 private static으로 선언하다. 여기서 중첩 클래스가 직렬화 프록시다.

다만 바깥 클래스와 직렬화 프록시 모두 `Serializable`을 구현해야 한다. 

- 바깥 클래스에 writeReplace
- 직렬화 프록시에 readResolve

### 직렬화 프록시 패턴의 한계

- 클라이언트가 확장할 수 있는 클래스에는 적용 불가
- 객체 그래프 순환이 있는 클래스에는 적용 불가
- 방어적 복사보다 느림

직렬화 프록시 패턴은 가장 안전한 직렬화 방법 중 하나이다.

---
