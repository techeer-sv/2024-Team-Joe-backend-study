## [Notion](https://basalt-bathroom-cb4.notion.site/10-14f16748c2828096ae68ef85a6e932e5?pvs=4)

## 10장 예외


## 예외는 진짜 예외 상황에만 사용하라

예외를 잘못 사용하는 경우를 만날 수 있다. 아래 코드는 무한루프를 돌다가 배열의 끝에 도달해 ArrayIndexOutOfBoundsException이 발생하여 끝을 내는 것이다.

```jsx
try {
    int i = 0;
    while(true)
        range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {

}
```

JVM 동작에 대한 이해 부족으로 인한 잘못된 추론의 결과다. 예외는 예외 상황에 사용할 용도로 설계되었기 때문에 JVM 구현자 입장에서 최적화에 별로 신경 쓰지 않았을 가능성이 크다.

- 외부 동기화 없이 여러 스레드가 동시 접근하는 경우 옵셔널이나 특정 값을 사용한다. 상태 검사 메서드와 상태 의존적 메서드의 호출 사이에서 객체의 상태가 변할 수 있기 때문이다.

- 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존전 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.

- 다른 경우에는 상태 검사 메서드 방식이 조금 더 낫다. 가독성이 조금 더 좋고, 잘못 사용했을 때 발견하기 쉽다. 상태 검사 메서드 호출을 잊었다면, 상태 의존적 메서드가 예외를 던져 버그 찾기가 수월할 것이다.

---

## **복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라**

자바는 문제 상황을 알리는 타입(throwable)으로 검사 예외, 런타임 예외, 에러 이렇게 세 가지를 제공하는데, 언제 무엇을 사용해야 하는지 헷갈려 하는 프로그래머들이 종종 있다.

호출하는 쪽에서 복구하리라 여겨지는 상황이라면 **검사 예외**를 사용하라. 검사 예외는 API 사용자에게 검사 예외를 던져주어 그 상황에서 회복해내라고 요구한 것이다. 검사 예외는 일반적으로 복구할 수 있는 조건일 때 발생한다. 따라서 호출자가 예외 상황에서 벗어나는데 필요한 정보를 알려주는 메서드를 함께 제공하는 것이 중요하다.

**비검사 thowable는** 런타임 예외와 에러가 존재한다. 이 둘은 프로그램에서 잡을 필요가 없거나 혹은 통상적으로 잡지 말아야 한다. 

💡 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자, 확실하지 않다면 비검사 예외를 던지자. 검사 예외도 아니고 런타임 예외도 아닌 throwable은 정의하지도 말자. 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.

---

## 필요 없는 검사 예외 사용은 피하라

검사 예외는 발생한 문제를 개발자가 처리하여 안전성을 높인다. 잘 활용하면 API와 프로그램의 질을 높일 수 있다. 하지만 과하게 사용하는 경우 오히려 사용하기 불편한 API가 될 수 있다.

API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자. 복구가 가능하고 호출자가 그 처리를 해주길 바란다면 옵셔널 반환도 생각하자.

---

## **표준 예외를 사용하라**

예외도 재사용하는 것이 좋더. 자바 라이브러리는 대부분 API에서 쓰기에 충분한 수의 예외를 제공한다.

표준 예외를 사용하면 얻는게 많다. 특히 여러분의 API가 다른 사람이 익히고 사용하기 쉬워진다는 것이다.

### 표준예외

- `IllegalArgumentException`
    - 허용하지 않는 값이 인수로 건네졌을 때
    - null의 경우는 NullPointerException이 처리
- `IllegalStateException`
    - 객체가 메서드를 수행하기에 적절하지 않은 상태일 때
- `NullPointerException`
    - null을 허용하지 않는 메서드에 null을 건넸을 때
- `IndexOutOfBoundsException`
    - 인덱스가 범위를 넘어섰을 때
- `ConcurrentModificationException`
    - 허용하지 않는 동시 수정이 발견됐을 때
- `UnsupportedOpertionException`
    - 호출한 메서드를 지원하지 않을 때

---

## **추상화 수준에 맞는 예외를 던지라**

메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버리면, 수행하려는 일과 관련 없어 보이는 예외가 튀어나올 수 있다. 이 문제를 피하려면 **예외 번역**을 사용하자.

상위 계층에서 저수준의 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다.

예외 연쇄

```jsx
try {
	... // 저수준 추상화 이용.
} catch (LowerLevelException e) {
	throw new HigherLevelExcetpion(...);
}
```

예외 연쇄용 생성자

```jsx
try {
	... // 저수준 추상화 이용.
} catch (LowerLevelException cause) {
	// 저수준 예외를 고수준 예외에 실어 보낸다.
	throw new HigherLevelExcetpion(cause);
}
```

무턱대고 예외를 전파하는 것보다야 예외 번역이 우수한 방법이지만, 그렇다고 남용하는 것은 좋지 않다. 가능하면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다. 

아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라. 이때 예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다,

---

## **메서드가 던지는 모든 예외를 문서화하라**

메서드가 던지는 예외는 그 메서드를 올바르게 사용하게 하는 중요한 정보다. 따라서 문서화하는데 충분한 시간을 써야 한다.

검사 예외는 항상 따로 선언하고, 각 예외가 발생하는 상황을  `@throws` 태그를 사용하여 정확히 문서화해야한다. 

검사 예외는 메서드 선언의 throws 문에 일일이 선언하지만, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자. 

검사냐 비검사냐에 따라 API 사용자가 해야 할 일이 달라지므로 이 둘을 확실히 구분해주는게 좋다. 

한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 클래스 설명에 추가하는 방법도 있다.

---

## **예외의 상세 메시지에 실패 관련 정보를 담으라**

예외를 잡지 못하여 프로그램이 실패하면 시스템에서 자동으로 스택 추적(stack trace) 정보를 출력해준다. 이때 출력되는 문자열은 `Throwable` 클래스의 toString 메서드에서 반환하는 클래스 이름과 상세 메시지이다.

실패 순간을 적절히 포착하려면 발생한 예외예 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 한다. 예를 들어, IndexOutOfBoundsException 이라면 범위의 최솟값, 최댓값 그리고 범위를 벗어난 인덱스의 값을 담아야 한다.

하지만 주의할 점도 있다.  보안과 관련한 정보는 포함해서는 안된다. 상세 메시지에 비밀번호나 암호화 키 같은 정보까지 담을 필요는 없다.

---

## **가능한 한 실패 원자적으로 만들라**

### 실패 원자적이란

호출한 메서드가 실패해도 호출 전 상태를 유지하는 것을 말한다. 가능하다면 실패 원자성을 지키는 것이 중요하다.

실패 원자적으로 만드는 방법

- 작업 수행에 앞서 매개변수의 유효성을 검사하는 것
- 실패할 가능성이 있는 모든 코드를, 객체의 상태를 바꾸는 코드보다 앞에 배치하는 것도 하나의 방법
- 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법

실패 원자성을 사용하지 않아야 하는 경우

- 멀티스레드 환경에서는 객체의 일관성이 깨질 수 있다
- 실패 원자성을 달성하기 위한 비용이나 복잡도가 큰 경우

---

## **예외를 무시하지 말라**

예외가 선언된 API는 그 메서드를 사용할 때 적절한 조치를 해야 한다는 뜻이다. 따라서 예외는 문제 상황에 잘 대처하기 위해 존재하는데 catch 블록을 비워두면 예외가 존재할 이유가 없어진다.

웬만한 경우가 아니면 예외를 무시하지 않도록 하자. 예측할 수 있는 예외 상황이든 프로그래밍 오류든, 빈 catch 블록으로 못 본 척 지나치면 그 프로그램은 오류를 내재한 채 동작하게 된다. 그러나 어느 순간 문제의 원인과 아무 상관없는 곳에서 갑자기 죽어버릴 수도 있다. 예외를 적절히 처리하면 오류를 완전히 피할 수도 있다. 무시하지 않고 바깥으로 전파되게만 놔둬도 최소한 디버깅 정보를 남긴 채 프로그램이 신속히 중단되게는 할 수 있다.
