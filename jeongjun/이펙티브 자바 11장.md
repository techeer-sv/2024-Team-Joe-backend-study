## [Notion](https://basalt-bathroom-cb4.notion.site/11-15416748c282801ab064eebf16c10f42?pvs=4)

# 동시성

스레드는 여러 활동을 동시에 수행할 수 있게 해준다. 하지만 동시성 프로그래밍은 단일 스레드 프로그래밍보다 어렵다. 잘못될 수 있는 일이 늘어나고 문제를 재현하기도 어려워지기 때문이다. 그렇다고 동시성 프로그래밍으로부터 언제까지나 도망 다닐 수는 없다. 

## 공유 중인 가변 데이터는 동기화해 사용하라

여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓸 때는 항상 동기화해야 한다. 그렇지 않으면 의도하지 않은 값을 읽게 될 수 있다.

동기화는 배타적 실행과 스레드 사이의 안정적인 통신에 사용된다. 여러 스레드가 같은 변수를 동기화없이 수정하는 중이라도, 항상 어떤 스레드가 정상적으로 저장한 값을 읽어옴을 보장한다.

이를 보고 원자적 데이터를 읽고 쓸 때 동기화를 사용하지 않는다면 위험하다.

수정이 완전히 반영된 값을 얻는 다는 것은 보장하지만,

한 스레드가 저장한 값이 다른 스레드에게 보이는가에 대한 가시성은 보장하지 않기 때문이다.

`synchronized` 사용하면 배타적 실행, 안정적 통신 모두 보장된다.

> 여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화 해야 한다. 동기화에 실패하면 응답 불가 상태에 빠지거나 안전 실패로 이어질 수 있다. 이는 디버깅 난이도가 가장 높은 문제에 속한다. VM에 따라 현상이 달라지기도 한다.
> 

---

## **과도한 동기화는 피하라**

동기화를 하지 않으면 문제가 된다. 하지만 과도한 동기화도 적지 않은 문제가 된다. 성능을 떨어뜨리고, 교착 상태에 빠뜨리고, 심지어는 예측할 수 없는 결과를 만들기도 한다.

과도한 동기화는 병렬로 실행할 기회를 잃고, 모든 코어가 메모리를 일관되게 보기 위한 지연시간이 진짜 비용이다. 또한 JVM의 코드 최적화를 제한하는 것도 고려해야 한다.

따라서 가변 클래스를 작성할 때는 두 가지 선택을 할 수 있다. 

1. 동기화를 전혀 하지말고, 그 클래스르르 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자.
2. 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자. 단, 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때 선택하자.

---

## **스레드보다는 실행자, 태스크, 스트림을 애용하라**

동시성 작업을 할 때는 작업 큐를 직접 생성할 수도 있겠지만, 복잡한 작업들(안전실패, 응답불가 예방)이 필요하기 때문에 java.util.concurrent 패키지의 실행자, 태스크, 스트림을 이용하는 편이 더 낫다.

### 실행자 프레임워크

- 작업 큐(work queue) 생성 
- `ExecutorService exec = Executors.newSingleThreadExecutor();`
- 실행자에서 테스크 실행
- `exec.execute(runnable);`
- 실행자 종료
    
     - `exec.shutdown();`
    

실행자 서비스는 다음과 같은 주요 기능을 가지고 있다.

- 특정 태스크가 완료되기를 기다림
    - `exec.submit(()  -> s.removeObserver(this)).get();`
- 태스크 모음 중 아무것 하나 혹은 모든 태스크가 완료되기를 기다림
    - `List<Future<String>> futures = exec.invokeAll(tasks);`
- 실행자 서비스가 종료하기를 기다림
    - `exec.awaitTermination(10, TimeUnit.SECONDS);`
- 완료된 태스크들의 결과를 차례로 받음
    - `ExecutorCompletionService<String> executorCompletionService =`
        
        `new ExecutorCompletionService<>(executorService);`
        
- 태스크를 특정 시간에 혹은 주기적으로 실행하게 함
    - `ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1);`

---

## **wait와 notify보다는 동시성 유틸리티를 애용하라**

> **wait와 notify 메서드**
Java에서 **스레드 간의 동기화**를 위해 사용되는 메서드
> 

wait와 notify는 올바르게 사용하기 어렵기 때문에 고수준의 동시성 유틸리티를 사용하자.

ex) 실행자 프레임워크, 동시성 컬렉션(concurrent collection), 동기화 장치(synchronizer)

### 동시성 컬렉션

`List`, `Queue`, `Map` 같은 표준 컬렉션 인터페이스에 동시성을 추가한 것이다. 높은 동시성을 위해 동기화를 내부에서 수행한다. 동시성을 무력화하는 것이 불가능하며, 외부에서 락(Lock)을 걸면 오히려 속도가 더 느려진다.

### 동기화 장치

스레드가 다른 스레드를 기다릴 수 있게 하여 서로의 작업을 조율할 수 있도록 해준다. 대표적인 동기화 장치로는 `CountDownLatch`와 `Semaphore`가 있으며 `CyclicBarrier`와 `Exchanger`도 있다. 가장 강력한 동기화 장치로는 `Phaser`가 있다.

---

## **스레드 안전성 수준을 문서화하라**

멀티스레드 환경에서도 api를 안전하게 사용하려면 클래스가 지원하는 스레드 안전성 수준을 명시해야 한다.

불변(immutable) : 해당 클래스의 인스턴스는 마치 상수와도 같아서 외부 동기화도 필요 없음

무조건적 스레드 안전(unconditionally thread-safe) : 해당 클래스의 인스턴스는 수정될 수 있지만 내부에서도 충실히 동기화하여 별도의 외부 동기화없이 동시에 사용해도 안전

조건부 스레드 안전(conditionally thread-safe) : 무조건적인 스레드 안전성과 같지만 일부 메서드는 동시에 사용하려면 외부 동기화가 필요

스레드 안전하지 않음(not thread-safe) : 해당 클래스의 인스턴스는 수정될 수 있음

스레드 적대적(thread-hostile) : 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않음

### 스레드 안정성 애노테이션

- @Immutable - 불변
- @ThreadSafe - 무조건적 스레드 안전 / 조건부 스레드 안전
- @NotThreadSafe - 스레드 안전하지 않음 / 스레드 적대적

앞의 코드에서는 lock 필드를 final로 선언했다. 이는 우연히라도 락 객체가 교체되는 일을 예방해준다. 일반적인 감시 락이든 java.util.concurrent.locks 패키지에서 가져온 락이든 락 필드는 항상 final로 선언하라.

비공개 락 객체 관용구는 무조건적 스레드 안전 클래스에서만 사용할 수 있다. 조건부 스레드 안전 클래스에서는 특정 호출 순서에 필요한 락이 무엇인지를 클라이언트에게 알려주어야 하므로 이 관용구를 사용할 수 없다 (비공개이므로).

---

## **지연 초기화는 신중히 사용하라**

> 지연 초기화(lazy initailization): 
필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법
> 

주로 최적화 용도로 쓰이거나, 클래스와 인스턴스 초기화 때 발생하는 위험한 순환 문제를 해결하는 효과도 있다. 하지만 꼭 필요할 때까지는 하지 않는 것을 추천한다. 대부분의 상황에서 일반적인 초기화가 지연 초기화보다 낫다.

### 지연 초기화가 필요할 때

- 인스턴스 중 그 필드를 사용하는 인스턴스 비율은 낮고, 해당 필드를 초기화하는 비용은 높을 때

지연 초기화 방법

1. 지연 초기화가 초기화 순환성(initialization circularity)을 깨뜨릴 것 같으면 synchronized를 단 접근자를 사용하자.

2. 성능 때문에 정적 필드를 초기화해야 한다면 **지연 초기화 홀더 클래스**를 사용하자.

3. 성능 때문에 인스턴스 필드를 지연 초기화해야 한다면 **이중검사(double-check)** 관용구를 사용하자. 


> 이중검사
멀티스레드 환경에서 성능을 최적화하면서 안전하게 객체를 초기화**하기 위해 사용하는 디자인 패턴
> 

---

## **프로그램의 동작을 스레드 스케줄러에 기대지 마라**

### **스레드 스케줄러에 의존하지 말자**

여러 스레드가 실행 중이면 운영체제의 스레드 스케줄러가 스케줄링한다. 이러한 스케줄링 정책은 운영체제마다 다를 수 있다. 그렇기 때문에 스케줄러의 동작 방식에 의존하며 안된다. 의존하게 되는 경우 스레드 스케줄러마다 성능이 달라질 수 있어 다른 플랫폼에 이식하기 어려워진다.

실행 가능한 스레드의 평균적인 수가 프로세스의 수보다 과도하게 많아서는 안된다.

- 스케줄러의 고민이 줄어든다. 실행 준비가 된 스레드들은 맡은 작업을 끝낼 떄 까지 계속 실행되도록 만들어야 한다.
- 실행자 프레임워크를 예로 들면, 스레드 풀의 크기를 적절히 설정하고 작업을 짧게 유지하면 된다. 다만 오히려 너무 짧으면 성능이 저하된다.

스레드는 절대 바쁜 대기 상태가 되면 안 된다.

- 공유 객체의 상태가 바뀔 때까지 쉬지 않고 검사해서는 안 된다는 뜻이다. 바쁜 대기(busy waiting) 상태는 스레드 스케줄러의 변덕에 취약하며 프로세서에 큰 부담을 주어 다른 유용한 작업이 실행될 기회가 박탈된다.
