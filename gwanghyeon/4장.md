# [4장 클래스와 인터페이스](https://soft-paneer-8c5.notion.site/4-1179ec391bb28030aeb8d7540333513d?pvs=4)

# 15. 클래스와 멤버의 접근 권한을 최소화하라

## 핵심 정리

> 프로그램 요소의 접근성은 가능한 한 최소한으로
> 
> 
> 최소한의 public API를 설계
> 
> 그 외 클래스, 인터페이스, 멤버가 공개되지 않도록 해야됨
> 
> public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져선 안된다.
> 
> public static final 필드가 참조하는 객체가 불변인지 확인
> 

### 캡슐화

- 객체의 속성과 행위(메서드)를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉한다.

### 정보은닉

- 캡슐화가 관련된 데이터와 함수를 묶어주는 장치에 반해 정보은닉은 캡슐속에 있는 데이터와 함수를 가운데 외부에 노출시키지 않고 내부에 숨기는 장치
    - 정보은닉이 되기 위해선 먼저 캡슐화가 되어 있어야 함.

→ 필요한 데이터와 함수만 공개(전부 은폐시 정보를 주고 받을 수 없음)

### 캡슐화의 장점

- 개발속도 높일 수 있음
    - 여러 컴포넌트 병렬 개발
- 성능최적화
- 재사용성 높음
- 큰 시스템 제작에 유리

### 멤버의 접근 수준

멤버에 부여할 수 있는 접근 수준

1. private 
    - 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
2. package-private 
    - 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다. 클래스 멤버의 접근 제한자를 명시하지 않으면 자동으로 적용되는 접근 수준이다. 단, 인터페이스의 멤버는 기본적으로 public이다.
3. protected
    - package-private의 접근 범위를 포함하며, 추가적으로 해당 클래스의 하위 클래스에서도 접근 가능
4. public
    - 모든 곳에서 접근 가능

# 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

## 핵심정리

> public 클래스는 절대 가변 필드에 직접 노출해서는 안된다.
> 
> 
> 하지만 package-private 클래스나 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 수 있다.
> 

→ 접근자와 변경자 메서드를 활용해 데이터를 캡슐화하자

# 17. 변경 가능성을 최소화하라

## 핵심정리

> 변경 가능성을 최소화하라
> 
> 
> 불변 클래스를 활용하자
> 

### 불변 클래스

- 인스턴스의 내부 값을 수정할 수 없는 클래스
- 불변 객체의 장점
    - 불변 객체는 단순하다
        - 생성된 시점의 상태를 파괴될 때까지 간직
    - 근본적으로 스레드 안전하여 따로 동기화할 필요가 없다.
    - 여러 스레드가 동시에 사용해도 훼손되지 않는다.
    - 불변 객체에 대해서는 그 어떤 스레드도 다른 스레드에 영향을 줄 수 없으니 안심하고 공유할 수 있다.
- 단점
    - 값이 다르면 독립된 객체로 만들어야한다.
    - 값의 가짓수가 많다면 큰 비용을 치러야한다.

<aside>
💡

- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.
- 다른 합당한 이유가 없다면 클래스의 모든 필드는 private final 이어야 한다.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다. 확실한 이유가 없다면 생성자와 정적 팩터리 메서드 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안 된다.
</aside>

### 클래스를 불변으로 만드는 5가지 규칙

1. 객체의 상태를 변경하는 메소드를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.
    - 상속을 막는 대표적인 방법은 final로 선언하는 것
3. 모든 필드를 final로 선언한다.
    - 새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건네도 문제없이 동작하게 보장해준다.
4. 모든 필드를 private으로 선언한다.
    - 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아준다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
    - 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 한다.

<aside>
💡

- Getter가 있다고 해서 무조건 Setter를 만들지 말자.
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
- 불변 클래스는 장점이 많으며, 단점은 특정 상황에서의 잠재적 성능 저하뿐이다.
- 단순한 값 객체는 항상 불변으로 만들자.
- String과 BigInteger처럼 무거운 값 객체도 불변으로 만들 수 있는지 고심한다.
- 성능 때문에 어쩔 수 없다면, 불변 클래스와 쌍을 이루는 가변 동반 클래스를 public 클래스로 제공하자
</aside>

# 18. 상속보다는 컴포지션을 사용하라

## 핵심정리

> 상속은 캡슐화를 해친다.
> 
> 
> 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야한다. ?
> 
> - is-a 관계일때도 안심할 수만은 없는 게, 하위 클래스와 패키지가 상위 클래스가 다르고 , 상위 클래스가 확장을 고려해 설계되지 않았다면 문제가 될 수 있다.
> 
> 상속은 취약점을 피하고자 상속 대신 컴포지션과 전달을 사용하자
> 
> 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 이는 하위 클래스보다 견고하고 강력하다.
> 

### 상속의 단점

- 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.
- 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. 그 여파로 코드 한 줄 건드리지 않은 하위 클래스가 오작동할 수 있다.

### 컴포지션

- 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하는 방식
- 기존 클래스가 새로운 클래스의 구성요소로 쓰임

→ 상속 방식은 구체 클래스 각각을 따로 확장해야 하며, 지원하고 싶은 상위 클래스의 생성자 각각에 대응하는 생성자를 별도로 정의해줘야 하지만, 컴포지션 방식은 한 번만 구현해두면 기존 생성자들과 함께 사용할 수 있음.

### 상속을 적절하게 사용하는 방법

- 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에만 쓰여야 한다. 즉, 클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야한다.

### 컴포지션 대신 상속을 사용하기로 결정하기 전 마지막 자문해야할 질문

1. 확장하려는 클래스의 API에 아무런 결함이 없는가?
2. 결함이 있다면, 이 결함이 클래스의 API까지 전파되어도 괜찮은가?
3. 컴포지션으로는 이런 결함을 숨기는 새로운 API를 설계할 수 있지만 상속은 상위 클래스의 API 결함까지 승계되는데 괜찮은가?

# 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

## 핵심정리

> 클래스를 확장할 명확한 이유가 떠오르지 않는다면 상속을 금지하는 편이 낫다.
> 
> 
> 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들자.
> 

상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.

### 상속을 금지하는 방법

- 클래스를 final로 선언
- 모든 생성자를 private나 package-private로 선언하고 public 정적 팩토리를 만들기

# 20. 추상 클래스보다는 인터페이스를 우선하라

## 핵심정리

> 다중 구현용 타입으로는 인터페이스가 가장 적합하다.
> 
> 
> 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법을 고려하자.
> 
> 골격 구현은 가능한 한 인터페이스의 디폴트 메서드를 제공하며, 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋다.
> 

자바가 제공하는 다중 구현 매커니즘은 추상 클래스와 인터페이스이다. 둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다.

### 믹스인

- 다른 클래스의 부모클래스가 되지 않으면서 다른 클래스에서 사용할 수 있는 메서드를 포함하는 클래스
    - 상속이 아니라 포함으로 설명됨
    - 코드의 재사용성을 높이고 다중 상속으로 인해 발생할 수 있는 상속의 모호성 문제를 제거하거나 언어에서 다중상속에 대한 지원부족을 해결하기 위해 사용될 수 있다.

# 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

## 핵심정리

> 구현하는 쪽을 생각해 설계하라
> 
> 
> 인터페이스를 설계할 때는 세심한 주의를 기울여야 한다.
> 
> 반드시 테스트를 거치고 서로 다른 방법으로는 3가지는 구현해보자
> 
> 바로잡을 기회가 아직 남았을 때 결함을 찾을 수 있다.
> 

### 디폴트 메서드 사용시 주의사항

- 디폴트 메서드는 컴파일에 성공하더라도 기존 구현체에서 런타임 오류를 일으킬 수 있다.
- 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다.
- 추가하려는 디폴트 메서드가 기존 구현체들과 충돌하지는 않을지 생각하자
- 디폴트 메서드는 `인터페이스로부터 메서드를 제거` 하거나 `기존 메서드의 시그니처를 수정` 하는 용도가 아니다.
- 새로운 인터페이스라면 릴리스 전 반드시 테스트를 거치자
- 서로 다른 방식으로 최소한 세 가지는 구현하자

# 22. 인터페이스는 타입을 정의하는 용도로만 사용하라

## 핵심정리

> 상수 공개용 수단으로 사용하지 말자
> 
> 
> 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다.
> 
> 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지 클라이언ㅌ한테 이야기 하는 것
> 
- 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할  수 있는 타입 역할로만 사용해야 한다.
- 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 것이다.

### 인터페이스 지침에 맞지 않게 사용한 예시 - 상수 인터페이스

- 상수 인터페이스란 메서드 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스이다.
- 이 상수들을 사용하려는 클래스에서는 정규화된 이름을 쓰는 걸 피하고자 그 인터페이스를 구현한다.

```java
public interface PhysicalConstants {
    // 아보가드로 수 (1/몰)
    static final double AVOGADRO_NUMBER = 6.022_140_857e23;
    // 볼츠만 상수 (J/K)
    static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;
    // 전자 질량 (kg)
    static final double ELECTRON_MASS = 9.109_383_56e-31;
}
```

### 올바르게 상수를 공개하는 방법

- 특정 클래스나 인터페이스와 강하게 연결된 상수라면 그 클래스나 인터페이스 자체에 추가한다.
- 열거 타입으로 나타내기 적합한 상수라면, 열거타입으로 만들어 공개한다.

```java
public class PhysicalConstants {
    
    private PhysicalConstants(){};  //인스턴스화 방지
    
    //아보가도르 수(1/몰)
    public static final double AVOGADROS_NUMBER = 6.002_140_857e23;
    //볼츠만 상수 (J/K)
    public static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;
    // 전자 질량 (kg)
    public static final double ELECTRON_MASS = 9.109_383_56e-31;
}
```

# 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라

## 핵심정리

> 새로운 클래스를 작성하는데 태그 필드가 등장한다면 태그를 없애고 계층구조로 대체하는 방법을 생각해보자. 기존 클래스가 태그 필드를 사용하고 있다면 계층구조로 리팩토링 하는걸 고민하자
> 

태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적이다.

### 태그 달린 클래스

두 가지 이상의 의미를 표현할 수 있으며, 그 중 현재 표현하는 의미를 태그 값으로 알려주는 클래스

- 단점
    - 열거 타입 선언, 태그 필드, switch문 등 쓸데없는 코드 많음
    - 여러 구현이 한 클래스에 있어서 가독성이 떨어짐
    - 다른 의미를 위한 코드가 함께 해서 메모리를 많이 사용함
    - 필드를 final로 선언하려면 해당 의미에 쓰이지 않는 필드까지 생성자에서 초기화해야 한다.
    - 생성자가 태그 필드를 설정하고 해당 의미에 쓰이는 데이터 필드를 초기화하는데 컴파일러가 도와줄 수 있는 건 별로 없다
    - 다른 의미를 추가하려면 코드를 수정해야 한다.
    - 인스턴스의 타입만으로 현재 나타내는 의미를 알 수 없다.

### 태그 달린 클래스의 대안 : 서브타이핑

- 서브 타이핑
    - 타입 계층을 구성하기 위해 상속을 사용
- 서브 클래싱
    - 다른 클래스 코드를 재사용하는 목적으로 상속을 사용

### 태그 달린 클래스를 클래스 계층구조로 바꾸는 방법

1. 계층구조의 루트가 될 추상 클래스를 정의
2. 태그 값에 따라 동작이 달라지는 메서드들을 루트 클래스의 추상 메서드로 선언한다.
3. 태그 값에 상관없이 동작이 일정한 메서드들을 루트 클래스에 일반 메서드로 추가한다.
4. 모든 하위 클래스에서 공통으로 사용하는 데이터 필드들로 전부 루트 클래스로 올린다.
5. 루트 클래스를 확장한 구체 클래스를 의미별로 하나씩 정의한다.
6. 루트 클래스가 정의한 추상 메서드를 각자의 의미에 맞게 구현한다.

# 24. 멤버 클래스는 되도록 static으로 만들라

## 핵심정리

> 중첩 클래스에는 4가지가 있다
> 
> 
> 메서드 밖에서도 사용하거나 메서드 안에 정의하기에 길다면 멤버 클래스로 만든다.
> 
> 멤버 클래스의 인스턴스 각각이 바같 인스턴스를 참조한다면 비정적으로, 그렇지 않다면 정적으로 만든다.
> 
> 중첩 클래스가 한 메서드 안에서만 쓰이며 그 인스턴스를 생성하는 지점이 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 있다면 익명 클래스로 만드록, 그렇지 않다면 지역 클래스로 만든다.
> 

### 중첩클래스

- 다른 클래스 안에 정의된 클래스
- 정적 멤버 클래스
    - 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다. 나머지는 일반 클래스와 같아.
- (비정적) 멤버 클래스
    - 어댑터를 정의할 때 자주 쓰인다.
    - 어댑터 패턴
        - 호환되지 않는 인터페이스들을 연결하는 디자인 패턴
        - 어댑터 : 타켓 인터페이스를 구현하여 클라이언트 요청을 어댑티로 전달하는 클래스

→ 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자.

- 익명 클래스
    - 이름이 없고 멤버와 달리 쓰이는 시점에 선언과 동시에 인스턴스가 만들어짐
    - 오직 비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다.
    - 제약
        - 선언한 지점에서만 인스턴스를 만들 수 있다.
        - instanceof 검사나 클래스의 이름이 필요한 작업은 수행할 수 없다.
        - 여러 인터페이스를 구현할 수 없다.
        - 인터페이스를 구현하는 동시에 다른 클래스를 상속할 수 없다.
        - 표현식 중간에 등장하므로 가독성이 떨어진다.
- 지역 클래스
    - 지역변수를 선언할 수 있는 곳이면, 어디서든 선언할 수 있고, 유효 범위도 지역변수와 같다.

# 25. 톱레벨 클래스는 한 파일에 하나만 담으라

## 핵심정리

> 소스 파일 하나에는 반드시 톱레벨 클래스(톱레벨 인터페이스)를 하나만 담자 ?
> 
> 
> 컴파일러가 한 클래스에 대한 정의를 여러개 만드는 일이 사라질 것이다.
> 
> 소스 파일을 어떤 순서로 컴파일하든 바이너리 파일이나 프로그램의 동작이 달라지는 일은 결코 일어나지 않을 것이다.
> 

단순히 톱레벨 클래스들을 서로 다른 소스 파일로 분리하자.
