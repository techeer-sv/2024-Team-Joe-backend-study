[9장 일반적인 프로그래밍 원칙](https://soft-paneer-8c5.notion.site/9-1589ec391bb2807da1a1cdcbb986d802?pvs=4)

---

# 아이템57 지역변수의 범위를 최소화하라

지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지 보수성은 높아지고 오류 가능성은 낮아진다. 아래는 지역변수의 범위를 좁히는 방법들이다.

### 57-1. 지역변수는 사용할 때 선언 및 할당해라

- 지역변수의 범위를 줄이는 가장 좋은 방법은 처음 쓸 때 선언과 동시에 초기화하는 것이다. 맨 위에서 미리 선언부터 잔뜩 해두면 가독성이 떨어진다. 또 사용시점엔 초기 값이 기억이 안날 수도 있다. 여기서 try-catch 문은 예외이다. 초기화하다가 예외를 던질수 있다면, try 바로 위에 선언하고, try 블록 안에서 초기화해주어야 한다

### 57-2. while문보다는 for을 사용하라

- 반복 변수의 값을 반복문이 종료된 뒤에도 써야하는 상황이 아니라면 while 문보다는 for 문을 쓰는 편이 낫다. while문은 반복변수를 반복문 바깥 블록에 선언해야하기 때문이다.

### 57-3. 메소드를 작게 유지하기

- **효과**: 메소드가 작고 단일 기능에 집중할수록 지역변수 범위 역시 자동으로 좁아진다.
- **결과**: 간결한 메소드 구조는 변수 관리에도 유리하다.

---

## 아이템58. 전통적인 for문보다는 foreach문(향상된 for문)을 사용하라

- **장점**: foreach문을 사용하면 인덱스나 반복자를 직접 다루지 않아 코드가 간결해지고, 오류 발생 가능성이 줄어든다.
- **적용 대상**: 배열, 컬렉션, Iterable 구현체 모두에 사용 가능.

### 부적절한 예시

```java
java
코드 복사
ArrayList<String> list = new ArrayList<>();
list.addAll(Arrays.asList("a", "b", "c", "d"));
System.out.println(list); // [a, b, c, d]

for (int i = 0; i < list.size(); i++) {
    list.remove(i);
    System.out.println(list);
    // 첫 회차: [b, c, d], 두 번째 회차: [b, d] 후 반복 종료
}

```

인덱스 기반으로 remove 시, 예상치 못한 동작 발생.

### 58-1. foreach문을 사용할 수 없는 경우

1. **파괴적인 필터링(destructive filtering)**: 순회하며 원소 제거 시 `Iterator.remove()` 필요, foreach 사용 불가.
2. **변형(transforming)**: 원소를 변형하려면 인덱스나 반복자 필요, foreach 사용 불가.
3. **병렬 반복(parallel iteration)**: 여러 컬렉션을 동기적으로 순회할 때 foreach만으로 처리 곤란.

---

## 아이템59. 라이브러리를 익히고 사용하라

- 이미 잘 만들어진 라이브러리를 사용하면 직접 구현하는 수고를 덜고, 성능 및 유지보수 측면에서도 이점이 있다.

### 59-1. 표준 라이브러리 사용 이유

- 전문가의 코드, 문서, 경험 활용 가능
- 핵심 로직에 집중 가능
- 지속적인 성능 개선과 기능 추가 혜택
- 많은 개발자가 익숙한 코드 -> 유지보수성 향상

### 추천 패키지

- `java.lang`
- `java.io`
- `java.util` (컬렉션, 스트림, 동시성 지원)

### 59-2. 서드파티 라이브러리

- Apache Commons, Google Guava, Jackson, Jsoup 등
- 원하는 기능이 표준 라이브러리에 없다면 서드파티 라이브러리를 활용할 수 있다.

---

## 아이템60. 정확한 답이 필요하다면 float와 double은 피하라

- float와 double은 이진 부동소수점 연산으로 근사치를 빠르게 계산하기 위해 설계되었다.
- 금융 계산처럼 정밀도가 필요한 경우 오차 발생 가능성이 있다.
    
    ```java
    java
    코드 복사
    1.03 - 0.42 = 0.6100000000000001
    
    ```
    

### 대안

- **BigDecimal**: 정확하지만 사용이 불편하고 느림.
- **int/long 사용**: 소수점을 직접 관리.
    - 9자리 십진수 이하 -> int
    - 18자리 십진수 이하 -> long
    - 그 이상 -> BigDecimal

---

## 아이템61. 박싱된 기본 타입보다는 기본 타입을 사용하라

### 차이점

- 원시 타입: 값만 가짐, null 불가
- 박싱 타입: 값 + 식별성(객체), null 가능, 성능 저하

### 문제점

1. **식별성 문제로 인한 오동작**
    
    ```java
    java
    코드 복사
    Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
    naturalOrder.compare(new Integer(82), new Integer(82)); // 기대:0, 실제:1
    ```
    
    `i == j`가 참조 비교를 하여 false 반환.
    
2. **NullPointerException 위험**
    
    ```java
    java
    코드 복사
    Integer i = null;
    if (i == 82) { // 언박싱 과정에서 NPE 발생
        ...
    }
    ```
    

### 박싱 타입이 필요한 경우

- 컬렉션, 제네릭 타입 매개변수, 리플렉션 메소드 호출 등 원시 타입을 직접 사용할 수 없는 상황.

---

## 아이템62. 다른 타입이 적절하다면 문자열 사용을 피하라

- 문자열은 텍스트 표현용. 숫자, 열거, 복합 객체, 권한 표현 등에 문자열을 오용하지 말 것.
- **대안**:
    - 숫자: int, long, BigDecimal 등 적절한 수치 타입
    - 열거: enum
    - 복합 타입: 전용 클래스
    - 권한: 적절한 객체나 인터페이스

---

## 아이템63. 문자열 연결은 느리니 주의하라

- 문자열은 불변이므로 문자열 연결 시 매번 새 객체 생성.
- n개의 문자열 연결 시 시간 복잡도가 O(n²)가 될 수 있다.

### 대안

- 반복적인 문자열 연결 시 `StringBuilder` 사용.
- 멀티스레드 환경 -> `StringBuffer` 고려.

### 컴파일러 최적화

- 상수 문자열 결합은 컴파일 시 최적화
- 변수나 반복문 내 문자열 결합은 StringBuilder로 변환되지만, 여전히 비효율적일 수 있으므로 명시적 사용 권장.

---

## 아이템64. 객체는 인터페이스를 사용해 참조하라

- 구현 클래스 대신 인터페이스 타입으로 선언하면 후에 구현체 교체가 용이.
- **예시**:
    
    ```java
    java
    코드 복사
    List<String> list = new ArrayList<>();
    // 이후 LinkedList로 교체할 때
    list = new LinkedList<>();
    ```
    
- 예외: 적합한 인터페이스가 없는 값 타입(String, Integer 등)은 그냥 클래스 타입 사용.
- PriorityQueue 같이 인터페이스에 없는 추가 기능이 필요한 경우 클래스 참조 필요.

### 인터페이스 설계에 대한 고려

- 새로운 구현체 추가 가능성이 낮아도, 인터페이스는 외부와의 약속이자 관심사의 분리 도구.
- 필요에 따라 인터페이스 도입 시점을 조정할 수 있다.

---

## 아이템65. 리플렉션보다는 인터페이스를 사용하라

- 리플렉션 단점:
    - 컴파일 타임 타입 체크 불가
    - 코드 장황, 복잡
    - 성능 저하
- **원칙**: 리플렉션은 인스턴스 생성에만 제한적으로 사용. 생성한 인스턴스는 인터페이스나 상위 클래스로 참조하여 코드 가독성과 안정성을 유지한다.

---

## 아이템66. 네이티브 메소드는 신중히 사용하라

- JNI를 통한 native 메소드 사용은 플랫폼 특화 기능, 기존 라이브러리 재활용, 성능 극대화 시 고려.
- 단점: 메모리 안전성 취약, GC 연계 어려움, 디버깅 난이도 증가.
- 자바 발전으로 native 사용 빈도는 점점 감소.

---

## 아이템67. 최적화는 신중히 하라

- 성능 때문에 구조적 우수성과 가독성을 희생하지 말 것.
- 실제 성능 병목지점에 집중하라.
- 프로파일링 도구 활용, 성능 측정 전후 비교 필수.

---

## 아이템68. 일반적으로 통용되는 명명 규칙을 따르라

일관성 있는 명명 규칙은 코드의 가독성과 협업 효율을 높인다.

### 철자 규칙

- **패키지/모듈명**: 모두 소문자, 점(.)으로 계층 구분, 도메인의 역순 사용 (예: `com.example.myapp`).
- **클래스/인터페이스명**: 각 단어 첫 글자 대문자 (예: `AppleTree`, `HttpRequestHandler`).
- **메소드/필드명**: 첫 글자 소문자, 상수 필드는 모두 대문자와 밑줄로 구분 (예: `size`, `getName()`, `MAX_SIZE`).
- **타입 매개변수**: 한 글자 (T, E, K, V, X, R).

### 문법 규칙

- 인스턴스를 생성할 수 있는 클래스명: 명사/명사구 (예: `Thread`, `User`).
- 인스턴스를 생성할 수 없는 유틸 클래스: 복수형 명사나 형용사 (예: `Collections`, `Executors`).
- 메소드명: 동사나 동사구 (예: `run()`, `calculateScore()`).
- 속성 반환 메소드: 명사 또는 `get` 접두사, boolean 반환 시 `is`로 시작 (예: `getName()`, `isEmpty()`).
- 다른 타입 객체 반환: `toType()` 형식 (예: `toString()`, `toArray()`).
- 다른 뷰 반환: `asType()` 형식 (예: `asList()`).
- 기본 타입 값 반환: `typeValue()` 형식 (예: `intValue()`, `doubleValue()`).

이러한 규칙을 따르면 코드의 의도를 명확히 드러낼 수 있고, 협업 시 예측 가능한 명명으로 커뮤니케이션이 용이해진다.
