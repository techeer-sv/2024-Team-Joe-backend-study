# [5장 제네릭](https://soft-paneer-8c5.notion.site/5-11d9ec391bb280a1ae7bc811622594c3?pvs=4)
---
# 26. raw type은 사용하지 말라

### raw type ❓

 제네릭 타입에서 타입 매개 변수를 전혀 사용하지 않은 타입을 말한다. 

- 타입 매개변수(ex. <E>)가 있으면 각각 제네릭 클래스, 제네릭 인터페이스라 함 → 제네릭 타입
- List<E> 제네릭 타입을 정의하면 raw type도 정의됨 → List<E>의 raw type은 List이다. 즉, 타입 매개변수를 쓰지 않은 경우

### raw type 사용 비추천

- raw type을 사용할 경우, unchecked 경고가 나오며, 잘못된 타입을 add할 수도 있음 → 런타임에서 문제가 생김
    - 이상적인 오류의 발견은 컴파일 타임에 되는 것
- raw type을 쓰지말고, 제네릭 타입을 쓴다면 컴파일러의 컴사력과 타입 불변, 안정성을 얻을 수 있다.

### raw type, 와일드 카드<?>, <Object>의 차이

```java
List rawList = new ArrayList<String>();
List<?> wildList = new ArrayList<String>();
ListM=<Object> genericList = new ArrayList<String>();

rawList.add("redboy");

wildList.add("redboy");
wildList.clear();
```

- <?>는 제네릭 타입 매개변수에 의존성이 있는 코드가 있다면 컴파일러가 실패처리한다. <Object>는 내부에서 또 다시 형 변환해야하므로 코드가 좀 더 복잡해지며, 제네릭의 장점이 사라진다.

# 27. 비검사 경고를 제거하라

- 비검사 경고를 제거하면 런타임에 형변환 관련 예외가 발생할 일이 없으며 코드의 올바른 동작도 기대할 수 있게 된다.
- 만약 경고를 제거할 수 없지만 타입이 안전하다고 확실할 수 있다면 @SuppressWarings(”unchecked”) 어노테이션을 붙여 경고를 숨기자. 리턴 문장을 제외한 개별 지역변수 선언부터 클래스 전체까지 어떤 선언에도 달 수 있지만, 가능한 좁은 범위에 적용해야 한다.

<aside>
💡

할 수 있는 한 모든 비검사 경고를 모두 제거하자.

</aside>

# 28. 배열보다는 리스트를 사용하라

배열 vs 제네릭

---

배열은 공변(cavariant)이다. 즉, sub 클래스가 Super라는 클래스의 하위 타입이라면, 배열 Sub[]은 배열 Super[]의 하위 타입이 된다. 이것을 공변이라고 한다. 하지만 제네릭 불공변(invariant)이다. 서로 다른 Type1과 Type2가 있을 때, List<Type1>은 List<Type2>의 상위 타입도 하위 타입도 아니다.

### 제네릭 배열을 만들지 못하게 막은 이유

- 타입이 안전하지 않기 때문
- 이를 허용한다면 컴파일러가 자동 생성한 형변환 코드에서 런타임에 ClassCastException이 발생할 수 있다.
- 런타임에 ClassCastException이 발생하는 일을 막아주겠다는 제네릭 타입 시스템의 취지의 어긋남

# 29. 이왕이면 제네릭 타입으로 만들어라

<aside>
💡

핵심정리

- 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다.
- 따라서 새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 해야한다.
    - 제네릭 타입으로 만들어야 할 경우가 많다.
- 기존 타입 중 제네릭이었어야 하는 게 있다면 제네릭 타입으로 변경하자.
- 기존 클라이언트에는 아무런 영향을 주지 않으면서, 새로운 사용자를 훨씬 편하게 해주는 길이다.
</aside>

### 일반클래스를 제네릭 클래스로 만드는 방법

1. 클래스 선언에 타입 매개변수를 추가
2. 일반 타입을 타입 매개변수로 교체
3. 비검사 경고 해결해주기

# 30. 이왕이면 제네릭 메소드로 만들어라

<aside>
💡

핵심 정리

- 제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기도 쉽다.
- 타입과 마찬가지로, 메서드도 형변환 없이 사용할 수 있는 편이 좋으며, 많은 경우 그렇게 하려면 제네릭 메서드가 되어야 한다.
</aside>

- 메소드도 제네릭이 가능하다면 사용 → 사용자 측에서 형변환 하는 것보다 안전하고 유연해짐.
    
    ```java
    public static Set union(Set s1, Set s2) { //-> <E> Set<E> union(Set<E> s1, Set<E> s2)
    	Set result = new HashSet(s1); // -> Set<E> result = new HashSet<>(s1);
    	result.addAll(s2);
    	return result;
    ```
    

# 31. 한정적 와일드카드를 사용해 API 유연성을 높여라

- 제네릭의 매개변수화 타입은 불공견이다
    
    ```java
    public void pushAll(Iterable<E> src) { // 타입 매개변수는 클래스 레벨에 정의됨
        for (E e : src) push(e);
    }
    
    // 메인메소드
    Stack<Number> numberStack = new Stack<>();
    Iterable<Integer> integers = ...;
    numberStack.pushAll(integers); // ERROR 발생. incompatible types: Iterable<Integer>
    ```
    
    - 에러가 발생하며, 원인은 불공변 때문이다. Iterable<number>가 넘어와야 하는데 Iterable<Integer>가 넘어왔으며, 이 둘은 서로 다른 타입이기 때문에 컴파일 에러가 발생한 것이다. 사실 논리적으로는 문제가 없어야하는데, 컴파일러는 이것을 문제로 삼았다.
    
    ### 한정적 와일드카드 타입을 사용하자
    
    - 한정적 와일드카드 타입을 사용하면 쉽게 해결할 수 있다. E의 Iterable이 아닌 E의 하위타입의 Iterable로 만들면 된다.
        - Iterable<Integer>도 문제없이 컴파일된다.
        
        ```jsx
        public void pushAll(Iterable<E> src) {
        	for(E e : src) push(e);
        }
        ```
        
        - 만약 E의 상위타입을 표현하고 싶다면 <? super E>라고 쓰면 된다.
    
    # 32. 제네릭과 가변인수를 함께 쓸 때는 신중해라
    
    - 가변인자를 받는 메소드를 호출하면 호출시점에 배열이 생긴다. 즉, 애초에 만들 수 없다던 제네릭 배열이 만들어지는 것이다. 이것은 가변인자가 실무에서 매우 유용하기 때문에 모순이지만 수용한 것이다. 다음은 제네릭 가변인자 메소드다
        
        ```jsx
        @SafeVarargs
        @SuppressWarnings("varags")
        public static <T> List<T> asList(T...a) {
        	return new ArrayList<>(a);
        }
        ```
        
        ### SafeVarargs
        
        - 제네릭 가변인자 메소드 작성자가 그 메소드가 타입 안전함을 보장하는 장치다. 컴파일러는 이것을 믿고 경고를 하지 않는다.
            1. 메소드가 제네릭 가변인자 배열에 아무것도 저장하지 않는다.
            2. 그 배열의 참조가 밖으로 노출되지 않는다.
            3. 즉, 순수하게 인수들을 전달하는 역할만 해야한다.
        
        → @SafeVarargs은 재정의할 수 없는 메소드에만 붙일 수 있다. 재정의한 메소드에서는 안전할 지 보장이 안되기 때문이다.
        
        ### 메서드가 안전한지 확신할 수 있는 이유
        
        - 가변 인수 메서드를 호출할 때 varargs 매개변수를 담는 제네릭 배열이 만들어진다. 메서드가 이 배열에 아무것도 저장하지 않고, 그 배열의 참조가 밖으로 노출되지 않는다면 타입이 안전하다.
        - varargs 매개변수 배열이 호출자로부터 그 메서드로 순수하게 인수들을 전달하는 일만 한다면, 그 메서드는 안전하다
        
        # 33. 타입 안전 이종 컨테이너를 고려하라
        
        <aside>
        💡
        
        핵심 정리
        
        - 컬렉션 API로 대표되는 일반적인 제네릭 형태에서는 한 컨테이너가 다룰 수 있는 타입 매개변수의 수가 고정되어 있다. 하지만 컨테이너 자체가 아닌 키를 타입 매개변수로 바꾸면 이런 제약이 없는 타입 안전 이종 컨테이너를 만들 수 있다.
        - 타입 안전 이종 컨테이너는 Class를 키로 쓰며, 이런 식으로 쓰이는 Class 객체를 타입 토큰이라 한다.
        - 직접 구현한 키 타입도 쓸 수 있다.
        </aside>
        
        ### 단일 원소 컨테이너
        
        - 제네릭은 Set<E>, Map<K, V> 등 단일원소 컨테이너에 흔히 쓰인다.
        - 하나의 컨테이너에서 매개변수화 할 수 있는 타입의 수는 제한된다.
        - 원인: 매개변수화되는 대상은 원소가 아닌 컨테이너 자신이기 때문이다.
        - 컨테이너의 일반적인 용도에 맞게 설계된 것이니 문제될 건 없다. Set에는 원소 타입을 뜻하는 단 하나의 타입 매개변수만 있으면 되고, Map에는 키와 값이 타입을 뜻하는 2개만 필요한 식
        
        ### 타입 안전 이종 컨테이너
        
        - 컨테이너 대신 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화 한 키를 함께 제공하는 식으로 위 문제를 해결할 수 있다.
            
            → 이러한 설계 방식을 타입 안전 이종 컨테이너 패턴이라고 한다.
