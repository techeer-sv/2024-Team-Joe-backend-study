## 3장
#### 모든 객체의 공통 메서드
___
##### 아이템10 equals는 일반 규약을 지켜 재정의하라
equals는 문자열을 비교하는 연산자다. 이 메서드는 함정이 많아 문제를 피하기 위한 가장 쉬운 방법은 아예 재정의하지 않는 것이다! 다음과 같은 상황에 해당한다면 재정의하지 않도록 하자.
- 각 인스턴스가 본질적으로 고유하다. -> 값을 표현하는게 아닌 동작하는 개체를 표현하는 클래스가 해당.(Thread가 대표적 예시)
- 인스턴스의 '논리적 동치성'을 검사할 일이 없다.
- 상위 클래스에서 재정의한 equals가 하위 클래스에서도 딱 들어맞는다.
- 클래스가 private 이거나 package-private이고 equals메서드를 호출할 일이 없다.

equals가 실수로라도 호출되는걸 방지하고 싶다면, 코드와 같이 구현해두자.
```
@Override public boolean equals(Object o) {
    throw new AssertionError(); //호출금지!
```
equals를 재정의해야 할때는 언제일까??<br/> 객체 식별성(물리적)이 아닌 논리적 동치성을 확인해야하는데, 논리적 동치성을 비교하도록 재정의되지 않았을때이다.
프로그래머는 값이 같은지를 비교하기 원해 equals를 사용할텐데 논리적 동치성을 확인하도록 재정의해두면, 값 클래스 비교는 물론 Map의 키와 Set의 원소로도 사용이 가능하다.
equals 재정의할 때, 따라야 하는 Object명세의 규약이다.
- 반사성 : null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true.
- 대칭성 : null이 아닌 모든 참조 값 x,y에 대해, x.equals(y)가 true면 y.equals(x)도 ture.
- 추이성 : null이 아닌 모든 참조 값 x,y,z에 대해, x.equals(y)가 true이고 y.equals(z)도 true면 x.equals(z)도 true.
- 일관성 : null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
- null-아님 : null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다.<br/>

규약자체는 어렵지 않아보인다. 반사성은 단순히 객체는 자기 자신과 같아야 한다는 뜻으로 어기기 어려워 보인다.<br/>
대칭성은 서로에 대한 동치여부에 똑같이 답해야 한다는 뜻이다.<br/>
추이성은 첫번째 객체와, 두번째가 같고 두번째 세번째가 같다면, 첫번째 세번째 객체도 같아야 한다는 뜻이다.<br/>
일관성은 두 객체가 같다면 수정되지 않는 한, 영원히 같아야 한다는 뜻이다.
null-아님은 모든 객체가 null과 같지 않아야 한다는 뜻이다.
<br/>
좋은 equals 재정의
1. ==연산자를 사용하여 자기 자신의 참조인지 확인하라.
2. instanceof 연산자로 입력이 올바른 타입인지 확인하라 null검사도 해준다.
3. 입력을 올바른 타입으로 형변환하라.
4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사하라.
5. 성능을 위해 다를 가능성이 더 크나,비용이 싼 필드를 먼저 고려해라.
___
##### 아이템 11 equals를 재정의하려거든 hashCode도 재정의하라
이는 Object 명세에서 발췌한 규약이다. 
1. equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
2. equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
3. equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다. 따라서 equals를 재정의하면 hashCode도 재정의해야한다.논리적으로 같은 객체는 같은 해시코드를 반환해야 함.<br/>

좋은 hashCode 작성법
- 이미 정의된 hashCode를 최대한 사용하라.
- 31을 곱해라. 홀수이면서 소수이기 때문에 31로 정했다. 짝수이고 오버플로가 발생한다면 정보를 잃게된다. 2를 곱하면 시프트 연산과 같은 결과를 내기 때문.
- equals 비교에 사용되지 않은 필드는 hashCode에서도 반드시 제외해야한다.
- 해시 충돌이 적은 방법을 써야한다면 Guava의 com.google.common.hash.Hashing을 참고하자.
- hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자. 그래야 클라이언트가 이 값에 의지하지 않게 되고, 추후에 계산방식을 바꿀 수도 있다.
___
##### 아이템 12 toString을 항상 재정의하라
toString의 일반 규약에 따르며, 간결하면서 사람이 읽기 쉬운 형태의 유익한 정보를 반환해야 한다.<br/>
toString의 규약은 "모든 하위 클래스에서 이 메서드를 재정의하라"고 한다.<br/>
toString을 잘 구현한 클래스는 시스템 디버깅이 쉽다.

좋은 toString 작성방법
- toString은 그 객체가 가진 주요 정보 모두를 반환하는 것이 좋다.
- 주석으로 반환하는 포맷을 명시하든 아니든 의도를 명확히 밝혀야 한다.
- toString 외에 객체의 값들을 얻어올 수 있는 API를 제공하자.

toString을 재정의하지 않아도 되는경우
- 대부분의 유틸리티 클래스
- 대부분의 enum 타입
- 상위 클래스에서 이미 알맞게 재정의한 경우
___
##### 아이템13 clone 재정의는 주의해서 진행하라
Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이지만, 문제는 메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected이다. Cloneable 인터페이스는 Object의 protected 메서드인 clone의 동작 방식을 결정한다. Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면 CloneNotSupportedException을 던진다.

실무에서 Cloneable을 구현한 클래스는 clone 메서드를 Public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대한다. 하지만 clone 메서드의 일반 규약은 허술하다..
<br/>
상위 클래스에서 super.clone()이 아니라 생성자를 호출해 반환해도 컴파일러는 정상으로 판단한다.
super.clone을 사용하면 이와같이 쓸 수 있다. 하위클래스에서 형변환이 추가로 필요하다.
```
@Override public PhoneNumber clone(){
    try{
        return (PhoneNumber) super.clone();
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}    
```
super.clone 호출을 try-catch 블록으로 감싼 이유는 Object의 클론 메서드가 검사예외인 CloneNotSupportedException을 던지도록 선언되었기 때문이다.

clone 재정의시 참고사항
1. clone 메소드는 사실상 생성자와 같은 효과를 낸다. 즉 clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.
2. cloneable을 구현하는 클래스는 clone을 재정의해준다. 이 때 접근제어자를 public으로 바꾸고, 반환형도 쓰기 편하게 자기 타입으로 바꾸고, throws절도 없애는걸 추천.
3. 상속용 클래스는 implements Cloneable 하면 안된다. 이것은 하위클래스에 정하게 해야한다.

clone 방식보다 복사 생성자와 복사 팩토리를 사용해라.<br/>
복사 생성자란 단순히 자신과 같은 클래스의 인스턴스를 인수로 받는 생성자를 말한다.
```
public Yum(Yum yum) { ... ]; //복사 생성자
public static Yum newInstance(Yum yum) { ... }; //복사 팩터리
```
복사 생성자와 복사 팩토리는 자기 타입을 인수로 받아 복사하는 방식을 취한다.<br/>
이것은 clone 방식의 단점이었던 언어모순,위험,허술한 스펙,final용법과의 충돌, 불필요한 checked exception, 형변환 등이 없다.
___
##### 아이템14 Comparable을 구현할지 고려하라
compareTo는 단순 동치성 비교에 더해 순서까지 비교할 수 있다. Comparable을 구현했다는 것은 클래스의 인스턴스들에는 자연적인 순서가 있음을 뜻한다 Comparable을 구현한 객체들의 배열은 Arrays.sort(a); 처럼 정렬 가능하다.
검색, 극단값 계산, 자동정렬되는 컬렉션 관리도 쉽게 할 수 있다. String이 Comparable을 구현하면 
```
public class WordList {
    public static void main(String[] args) {
        Set<String> s = new TreeSet<>();
        Collections.addAll(s, args);
        System.out.println(s);
    }
}
```
중복을 제거한 인수들을 알파벳순으로 출력한다.<br/>
compareTo의 규약 -> equals의 규약과 비슷.
1. 이 객체와 주어진 객체의 순서를 비교한다.
2. 이 객체가 주어진 객체보다 작으면 음의정수를, 같으면 0을, 크면 양의정수를 반환한다.
3. 이 객체와 비교할 수 없는 타입의 객체가 주어지면 ClassCastException을 던진다.
4. 두 객체 참조의 순서를 바꿔서 비교해도 예상한 결과가 나와야한다.
5. 첫번째 객체가 두번째 객체보다 크고, 두번째 객체가 세번째 객체보다 크면, 첫번째 객체는 세번째 객체보다 커야한다.
6. 크기가 같은 객체들끼리는 어떤 객체와 비교하더라도 항상 같아야한다.
7. (권장) compareTo의 동치성 결과가 euqals와 같아야 한다.

compareTo메서드로 수행하는 동치성 검사도 equals규약과 똑같이 반사성, 대칭성, 추이성을 충족해야 함을 뜻한다. 주의사항도 같다. 기존 클래스를 확장한 구체 클래스에서 새로운 값 컴포넌트를 추가했다면 compareTo 규약을 지킬 방법이 없다.우회법도 동일하다.

compareTo의 작성요 -> equals와 비슷하다. 몇가지 차이점만 주의하자
1. Comparable은 제네릭 인터페이스이므로 입력 인수의 타입을 확인하거나 형변환할 필요가 없다.
2. compareTo 메서드는 각 필드가 동치인지를 비교하는게 아닌 그 순서를 비교한다.
3. 객체 참조 필드를 비교하려면 compareTo 메서드를 재귀적으로 호출한다.
4. Comparable을 구현하지 않은 필드나 표준이 아닌 순서로 비교해야한다면 비교자를 대신 사용한다.
5. 기본 정수타입을 비교할 때, 관계연산자보다 정적메소드 compare을 사용하라
6. 핵심적인 필드부터 비교해라.
